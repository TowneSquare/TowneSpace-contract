/*
    - This module is the main entry point for the studio.
    - It is responsible for creating collections, creating tokens,
    and composing and decomposing tokens.
    - It is also responsible for transferring tokens.

    TODO:
        - add a view function to get all active capabilties for a given collection
        - add a view function to get all active capabilties for a given token

*/

module townespace::studio {
    use aptos_framework::account;
    use aptos_framework::fungible_asset::{FungibleStore}; 
    use aptos_framework::object::{Self, Object};
    use aptos_std::smart_table::{Self, SmartTable};
    // use std::error;
    use std::option::{Self, Option};
    use std::signer;
    use std::string::{String};
    use std::vector;

    use townespace::core::{
        Self, 
        Composable,
        Trait
        };

    use townespace::events;

    // ---------------
    // Entry Functions
    // ---------------
    
    // Create a new collection
    public entry fun create_collection<T: key>(
        creator_signer: &signer,
        description: String,
        max_supply: Option<u64>, // if the collection is set to haved a fixed supply.
        name: String,
        symbol: String,
        uri: String,
        royalty_numerator: u64,
        royalty_denominator: u64,
        is_burnable: bool,
        is_mutable: bool
    ) {
        let collection_object = core::create_collection_internal<T>(
            creator_signer,
            description,
            max_supply,
            name,
            symbol,
            uri,
            royalty_numerator,
            royalty_denominator,
            false,
            false
        );
        
        events::emit_collection_created_event(
            signer::address_of(creator_signer),
            events::collection_metadata(collection_object)
        );
    }

    // create a composable token
    public entry fun create_composable_token(
        creator_signer: &signer,
        collection_name: String,
        description: String,
        type: String,
        uri: String, 
        traits: vector<Object<Trait>>,
        royalty_numerator: u64,
        royalty_denominator: u64
    ) {
        let token_object = core::create_token_internal<Composable>(
            creator_signer,
            collection_name,
            description,
            type,
            uri, 
            traits,
            smart_table::new<String, Object<FungibleStore>>(),
            royalty_numerator,
            royalty_denominator
        );
        
        events::emit_composable_token_created_event(
            signer::address_of(creator_signer),
            events::composable_token_metadata(token_object)
        );
    }

    public entry fun create_trait_token(
        creator_signer: &signer,
        collection_name: String,
        description: String,
        type: String,
        uri: String,
        royalty_numerator: u64,
        royalty_denominator: u64
    ) {
        let token_object = core::create_token_internal<Trait>(
            creator_signer,
            collection_name,
            description,
            type,
            uri, 
            vector::empty(),
            smart_table::new(),
            royalty_numerator,
            royalty_denominator
        );
        
        events::emit_trait_token_created_event(
            signer::address_of(creator_signer),
            events::trait_token_metadata(token_object)
        );
    }

    // TODO: delete collection

    // Burn composable token
    /*
        This will involve decomposing the composable token, 
        transferring all the associated object tokens
        to the owner, and then burning the aptos token.
    */

    // Compose one object
    public entry fun equip_trait(
        owner_signer: &signer,
        composable_object: Object<Composable>,
        trait_object: Object<Trait>,
        new_uri: String // User should not prompt this! It should be generated by the studio.
    ) {
        // TODO: assert input sanitazation 
        core::equip_trait_internal(owner_signer, composable_object, trait_object);
        // Update uri
        update_uri(
            object::object_address(&composable_object),
            new_uri
            );
    }

    // Decompose one object
    public entry fun unequip_trait(
        owner_signer: &signer,
        composable_object: Object<Composable>,
        trait_object: Object<Trait>,
        new_uri: String // User should not prompt this! It should be generated by the studio.
    ) {
        // TODO: assert input sanitazation 
        // TODO: assert owner
        core::unequip_trait_internal(owner_signer, composable_object, trait_object);
        // Update uri
        update_uri(
            object::object_address(&composable_object), 
            new_uri
            );
    }

    // Decompose an entire composable token
    // public entry fun decompose_entire_token(
    //     owner_signer: &signer,
    //     collection_name: String,
    //     composable_object: Object<Composable>,
    //     new_uri: String // User should not prompt this! It should be generated by the studio.
    // ) {
    //     // TODO: assert input sanitazation 
    //     // TODO: iterate through the vector and unequip traits
    //     // core::unequip_trait_internal(owner_signer, composable_object); 
    //     // Update uri
    //     // update_uri(owner_signer, collection_name, composable_token_object, new_uri);
    //     // TODO: events
    // }

    // Directly transfer a token to a user.
    // public entry fun raw_transfer<T: key>(
    //     owner_signer: &signer, 
    //     token_address: address,
    //     new_owner_address: address,
    // ) {
    //     // TODO: assert input sanitazation 
    //     // TODO: core::transfer
    //     // TODO: events
    // }

    // Transfer with a fee function
    // public entry fun transfer_with_fee<T: key>(
    //     owner_signer: &signer,
    //     token_address: address,
    //     new_owner_address: address,
    //     //fee: u64
    // ){
    //     // TODO: assert input sanitazation 
    //     // TODO: core::transfer
    //     // TODO: events
    // }

    // --------
    // Mutators
    // --------
    
    // Composable Token
    inline fun update_uri(
        composable_object_address: address,
        new_uri: String
    ) {
        // TODO: asserts 
        core::update_uri_internal(
            composable_object_address, 
            new_uri
            );
        // TODO: events
    }

}