/*
    - This module is the main entry point for the studio.
    - It is responsible for creating collections, creating tokens,
    and composing and decomposing tokens.
    - It is also responsible for transferring tokens.

    TODO:
        - add a view function to get all active capabilities for a given collection
        - add a view function to get all active capabilities for a given token

*/

module townespace::studio {
    use aptos_framework::object::{Self, Object};
    use std::option::{Option};
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use townespace::core::{Self, Composable, Trait};
    use townespace::events;

    // ---------------
    // Entry Functions
    // ---------------
    
    // Create a new collection
    public entry fun create_collection<T: key>(
        creator_signer: &signer,
        description: String,
        max_supply: Option<u64>, // if the collection is set to haved a fixed supply.
        name: String,
        symbol: String,
        uri: String,
        royalty_numerator: u64,
        royalty_denominator: u64,
        is_burnable: bool,
        is_mutable: bool
    ) {
        let collection_object = core::create_collection_internal<T>(
            creator_signer,
            description,
            max_supply,
            name,
            symbol,
            uri,
            royalty_numerator,
            royalty_denominator,
            false,
            false
        );
        
        events::emit_collection_created_event(
            signer::address_of(creator_signer),
            events::collection_metadata(collection_object)
        );
    }

    // create a composable token
    public entry fun create_composable_token(
        creator_signer: &signer,
        collection_name: String,
        description: String,
        uri: String,   
        base_mint_price: u64,
        traits: vector<Object<Trait>>,
        royalty_numerator: u64,
        royalty_denominator: u64
    ) {
        let token_object = core::create_token_internal<Composable>(
            creator_signer,
            collection_name,
            description,
            uri, 
            string::utf8(b""),
            traits,
            base_mint_price,
            royalty_numerator,
            royalty_denominator
        );
        
        events::emit_composable_token_created_event(
            signer::address_of(creator_signer),
            events::composable_token_metadata(token_object)
        );
    }

    public entry fun create_trait_token(
        creator_signer: &signer,
        collection_name: String,
        description: String,
        type: String,
        uri: String,  
        base_mint_price: u64,
        royalty_numerator: u64,
        royalty_denominator: u64
    ) {
        let token_object = core::create_token_internal<Trait>(
            creator_signer,
            collection_name,
            description,
            type,
            uri,   
            vector::empty(),
            base_mint_price,
            royalty_numerator,
            royalty_denominator
        );
        
        events::emit_trait_token_created_event(
            signer::address_of(creator_signer),
            events::trait_token_metadata(token_object)
        );
    }

    // Burn token
    /*
        This will involve decomposing the composable token, 
        transferring all the associated object tokens
        to the owner, and then burning the aptos token.
    */
    public entry fun burn_composable_token(signer_ref: &signer, token_object: Object<Composable>) {
        core::burn_token<Composable>(signer_ref, token_object);
    }

    public entry fun burn_trait_token(signer_ref: &signer, token_object: Object<Trait>) {
        core::burn_token<Trait>(signer_ref, token_object);
    }

    // Compose one object
    public entry fun equip_trait(
        owner_signer: &signer,
        composable_object: Object<Composable>,
        trait_object: Object<Trait>,
        new_uri: String // User should not prompt this! It should be generated by the studio.
    ) {
        // TODO: assert input sanitazation 
        core::equip_trait_internal(owner_signer, composable_object, trait_object);
        // Update uri
        update_uri(
            object::object_address(&composable_object),
            new_uri
            );
    }

    // Decompose one object
    public entry fun unequip_trait(
        owner_signer: &signer,
        composable_object: Object<Composable>,
        trait_object: Object<Trait>,
        new_uri: String // User should not prompt this! It should be generated by the studio.
    ) {
        core::unequip_trait_internal(owner_signer, composable_object, trait_object);
        // Update uri
        update_uri(
            object::object_address(&composable_object), 
            new_uri
            );
    }

    // Decompose an entire composable token
    // TODO: should be tested
    public entry fun decompose_entire_token(
        owner_signer: &signer,
        composable_object: Object<Composable>,
        new_uri: String // User should not prompt this! It should be generated by the studio.
    ) {
        // iterate through the vector and unequip traits
        let traits = core::get_traits(composable_object);
        let i = 0;
        while (i < vector::length<Object<Trait>>(&traits)) {
            let trait_object = *vector::borrow(&traits, i);
            core::unequip_trait_internal(owner_signer, composable_object, trait_object);
            i = i + 1;
        };
        // Update uri
        update_uri(object::object_address(&composable_object), new_uri);
    }

    // Directly transfer a token to a user.
    public entry fun transfer_digital_asset<T: key>(
        owner_signer: &signer, 
        token_address: address,
        new_owner_address: address,
    ) {
        core::transfer_token<T>(owner_signer, token_address, new_owner_address);
    }

    // Directly transfer a token to a user.
    public entry fun transfer_fungible_asset<FA: key>(
        signer_ref: &signer,
        recipient: address,
        fa: Object<FA>,
        amount: u64
    ) {
        core::transfer_fa<FA>(signer_ref, recipient, fa, amount);
    }

    // --------
    // Mutators
    // --------
    
    // set token name
    public entry fun set_token_name(
        signer_ref: &signer,
        token_object_address: address,
        new_name: String
    ) {
        core::set_token_name_internal(signer_ref, token_object_address, new_name);
    }

    // Composable Token
    inline fun update_uri(
        composable_object_address: address,
        new_uri: String
    ) {
        // TODO: asserts 
        core::update_uri_internal(
            composable_object_address, 
            new_uri
        );
        // TODO: events
    }

}